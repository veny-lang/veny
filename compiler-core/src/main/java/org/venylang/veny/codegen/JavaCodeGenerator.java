/*
 * Copyright 2025 Stoyan Petkov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package org.venylang.veny.codegen;

import org.venylang.veny.parser.ast.*;
import org.venylang.veny.parser.ast.expression.*;
import org.venylang.veny.parser.ast.statement.*;
import org.venylang.veny.semantic.Type;
import org.venylang.veny.semantic.types.BuiltinType;
import org.venylang.veny.util.Visibility;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * A visitor implementation that generates Java source code from a Veny AST.
 * <p>
 * This generator traverses the abstract syntax tree (AST) using the visitor pattern
 * and builds formatted Java code using a {@link CodeBuilder}. Currently, only class
 * and field declarations are partially implemented; other visit methods are placeholders.
 * </p>
 *
 * <p>Usage example:
 * <pre>{@code
 * Program ast = ... // Veny AST
 * JavaCodeGenerator generator = new JavaCodeGenerator();
 * String javaCode = ast.accept(generator);
 * System.out.println(javaCode);
 * }</pre>
 *
 * <p>The generated output includes a standard file header indicating that it was
 * auto-generated by the Veny compiler. This helps prevent manual edits and aids traceability.</p>
 *
 * @see AstVisitor
 * @see CodeBuilder
 */
public class JavaCodeGenerator implements AstVisitor<Void> {
    private final CodeBuilder builder = new CodeBuilder();
    private String entryClassName = null;
    private String entryPackageName = null;
    private String currentPackageName = null; // tracks package during file traversal
    private boolean insideEntryMethod = false; // tracks if inside entry() method
    private String currentClassName = null;
    private final Set<String> usedRuntimeImports = new HashSet<>();
    private final Set<String> knownClasses = new HashSet<>();
    private String currentMethodName = null;

    private JavaCodeGenerator() {}

    /**
     * Factory method to generate code from a given Program node.
     *
     * @param program the root AST node
     * @return an instance of JavaCodeGenerator with code ready to fetch
     */
    public static JavaCodeGenerator of(Program program) {
        JavaCodeGenerator generator = new JavaCodeGenerator();

        for (VenyFile f : program.files()) {
            for (ClassDecl c : f.classes()) {
                generator.knownClasses.add(c.name());
            }
        }

        program.accept(generator);
        return generator;
    }

    /**
     * Returns the generated Java source code as a string.
     */
    public String getCode() {
        return builder.build();
    }

    @Override
    public Void visit(Program node) {
        builder.appendRawLine(generateFileHeader("Veny", LocalDate.now().toString()))
                .appendRawLine(""); // blank line after header

        for (VenyFile file : node.files()) {
            file.accept(this);
            builder.appendRawLine(""); // separate files
        }

        return null;
    }

    @Override
    public Void visit(VenyFile node) {
        currentPackageName = node.packageName();

        if (node.packageName() != null && !node.packageName().isEmpty()) {
            builder.appendLine("package " + node.packageName() + ";");
            builder.appendRawLine(""); // blank line after package
        }

        for (ClassDecl cls : node.classes()) {
            cls.accept(this);
            builder.appendRawLine(""); // separate classes
        }

        // Now emit imports
        if (!usedRuntimeImports.isEmpty()) {
            List<String> imports = usedRuntimeImports.stream()
                .sorted()
                .map(imp -> "import " + imp + ";")
                .toList();
            builder.insertAfterPackage(imports);
        }
        return null;
    }

    @Override
    public Void visit(ClassDecl node) {
        String prevClass = currentClassName;

        currentClassName = node.name(); // track current class
        knownClasses.add(currentClassName);

        StringBuilder classSignature = new StringBuilder("public class ").append(node.name());

        // Handle optional superclass (ext)
        if (node.parent() != null && !node.parent().isEmpty()) {
            classSignature.append(" extends ").append(node.parent());
        }

        // Handle implemented interfaces (impl)
        if (!node.interfaces().isEmpty()) {
            classSignature.append(" implements ");
            classSignature.append(String.join(", ", node.interfaces()));
        }

        builder.appendLine(classSignature  + " {")
                .indent();

        // Emit fields
        for (VarDecl field : node.fields()) {
            field.accept(this);
        }

        if (!node.fields().isEmpty() && !node.methods().isEmpty()) {
            builder.appendRawLine(""); // Blank line between fields and methods
        }

        // Determine whether a user declared a no-arg constructor
        boolean userHasNoArgCtor = node.methods().stream()
                .anyMatch(m -> m.name().equals(node.name()) && m.parameters().isEmpty());

        // Track if we generate one
        boolean generatedNoArgCtor = false;

        // If there's no user no-arg ctor, possibly generate a default one.
        if (!userHasNoArgCtor) {
            // Collect final (immutable) fields that need initialization
            List<VarDecl> finalFieldsNeedingInit = node.fields().stream()
                    .filter(f -> !f.isMutable() && f.initializer() == null)
                    .collect(Collectors.toList());

            if (finalFieldsNeedingInit.isEmpty()) {
                // Safe to emit an empty public no-arg constructor
                builder.appendLine("public " + node.name() + "() {")
                        .indent()
                        .appendLine("// default constructor")
                        .unindent()
                        .appendLine("}")
                        .appendRawLine("");
            } else {
                // Emit constructor that initializes final fields to sensible defaults
                builder.appendLine("public " + node.name() + "() {")
                        .indent();
                for (VarDecl f : finalFieldsNeedingInit) {
                    String defaultVal = defaultValueForType(f.typeName());
                    // assign to this.field
                    builder.appendLine("this." + f.name() + " = " + defaultVal + ";");
                }
                builder.unindent()
                        .appendLine("}")
                        .appendRawLine("");
            }
            generatedNoArgCtor = true;
        }

        // Emit methods (user-defined)
        for (MethodDecl method : node.methods()) {
            method.accept(this);
            builder.appendRawLine(""); // Blank line between methods
        }

        // ðŸ” Check if this class has an entry method
        boolean hasEntry = node.methods().stream()
                .anyMatch(m -> m.name().equals("entry"));

        // Final decision: do we have a no-arg ctor?
        boolean noArgCtorExists = userHasNoArgCtor || generatedNoArgCtor;

        if (hasEntry  && noArgCtorExists) {
            usedRuntimeImports.add("org.venylang.veny.runtime.core.VenyText");

            builder.appendRawLine("")
                .appendLine("// Auto-generated launcher for Veny's entry")
                .appendLine("public static void main(String[] args) {")
                .indent()
                .appendLine("VenyText[] venyArgs = new VenyText[args.length];")
                .appendLine("for (int i = 0; i < args.length; i++) {")
                .indent()
                .appendLine("venyArgs[i] = VenyText.of(args[i]);")
                .unindent()
                .appendLine("}")
                .appendLine("new " + node.name() + "().entry(venyArgs);")
                .unindent()
                .appendLine("}");
        } else if (hasEntry) {
            // Could not auto-generate launcher because no safe no-arg constructor
            builder.appendRawLine("")
                    .appendLine("// NOTE: no no-arg constructor available; auto-main not generated for this class.")
                    .appendRawLine("");
        }

        builder.unindent()
                .appendLine("}");

        setEntryClassName(node);

        currentClassName = prevClass; // restore when leaving the class
        return null;
    }

    @Override
    public Void visit(InterfaceDecl node) {
        return null;
    }

    @Override
    public Void visit(VarDecl node) {
        String visibility = mapVisibility(node.visibility());
        if (visibility.isEmpty()) visibility = "private";

        String type = mapType(node.typeName());

        StringBuilder line = new StringBuilder();
        line.append(visibility).append(" ");
        if (!node.isMutable()) line.append("final ");

        line.append(type).append(" ").append(node.name());

        if (node.initializer() != null) {
            line.append(" = ").append(exprToJava(node.initializer()));
        }

        line.append(";");
        builder.appendLine(line.toString());
        return null;
    }

    @Override
    public Void visit(MethodDecl node) {
        boolean isConstructor = node.name().equals(currentClassName);

        String visibility = node.visibility().toString().toLowerCase();
        String prefix = visibility.equals("default") ? "" : visibility + " ";

        // Track current method
        String prevMethod = currentMethodName;
        currentMethodName = node.name();

        // Parameters
        StringBuilder params = new StringBuilder();
        for (int i = 0; i < node.parameters().size(); i++) {
            var param = node.parameters().get(i);
            params.append(mapType(param.type()))
                    .append(" ")
                    .append(param.name());
            if (i < node.parameters().size() - 1) {
                params.append(", ");
            }
        }

        if (isConstructor) {
            // Constructor: no return type
            builder.appendLine(prefix + currentClassName + "(" + params + ") {").indent();
        } else { // Method signature
          String returnType = mapType(node.returnType());
          builder
              .appendLine(
                  prefix + mapType(node.returnType()) + " " + node.name() + "(" + params + ") {")
              .indent();
        }

        // Track entry method context; mark if we're in entry()
        boolean prevInside = insideEntryMethod;
        if (node.name().equals("entry")) {
            insideEntryMethod = true;
        }

        // Body
        for (Statement stmt : node.body()) {
            stmt.accept(this);
        }


        insideEntryMethod = prevInside; // restore previous state
        currentMethodName = prevMethod; // restore previous method
        builder.unindent().appendLine("}");
        return null;
    }

    @Override
    public Void visit(BlockStmt node) {
        for (Statement stmt : node.statements()) {
            stmt.accept(this);
        }
        return null;
    }

    @Override
    public Void visit(IfStmt node) {
        String condition = exprToJava(node.condition());

        // unwrap VenyBool to primitive boolean
        Type condType = node.condition().getResolvedType();
        /*if (condType == BuiltinType.BOOL) {
            condition = condition + ".raw()";
        }*/

        builder.appendLine("if (" + condition + ") {").indent();
        node.thenBranch().accept(this);
        builder.unindent().appendLine("}");

        if (node.elseBranch() != null) {
            builder.appendLine("else {").indent();
            node.elseBranch().accept(this);
            builder.unindent().appendLine("}");
        }
        return null;
    }


    @Override
    public Void visit(WhileStmt node) {
        return null;
    }

    @Override
    public Void visit(ForStmt node) {
        return null;
    }

    @Override
    public Void visit(ReturnStmt node) {
        // Skip return statements in constructors
        if (currentClassName != null && insideConstructor()) {
            return null;
        }

        if (node.value() == null) {
            builder.appendLine("return VenyVoid.get();");
        } else {
            String exprCode = exprToJava(node.value());
            builder.appendLine("return " + exprCode + ";");
        }
        return null;
    }

    @Override
    public Void visit(ExprStmt node) {
        String exprCode = exprToJava(node.expression());
        if (!exprCode.isEmpty()) {
            builder.appendLine(exprCode + ";");
        }
        return null;
    }

    @Override
    public Void visit(VarStmt node) {
        String javaType = mapType(node.type()); // infer or declared type
        String initializer = (node.initializer() != null)
                ? exprToJava(node.initializer())
                : "null"; // or default for primitives
        builder.appendLine(javaType + " " + node.name() + " = " + initializer + ";");
        return null;
    }

    @Override
    public Void visit(ValStmt node) {
        String javaType = mapType(node.type());
        String initializer = (node.initializer() != null)
                ? exprToJava(node.initializer())
                : "null";
        builder.appendLine("final " + javaType + " " + node.name() + " = " + initializer + ";");
        return null;
    }

    @Override
    public Void visit(BinaryExpr node) {
        builder.appendLine(exprToJava(node) + ";");
        return null;
    }

    @Override
    public Void visit(UnaryExpr node) {
        return null;
    }

    @Override
    public Void visit(LiteralExpr node) {
        return null;
    }

    @Override
    public Void visit(VariableExpr node) {
        System.out.println("CG visiting Variable " + node.name());
        if (node.getResolvedType() == null) {
            System.err.println("WARNING: Variable " + node.name() + " has null type at codegen!");
        }
        return null;
    }

    @Override
    public Void visit(AssignExpr node) {
        return null;
    }

    @Override
    public Void visit(CallExpr node) {
        // Code generation for calls should go through exprToJava()
        // Not directly appended here.
        builder.appendLine(exprToJava(node) + ";");
        return null;
    }

    @Override
    public Void visit(NewExpr node) {
        return null;
    }

    @Override
    public Void visit(GetExpr node) {
        return null;
    }

    @Override
    public Void visit(SetExpr node) {
        return null;
    }

    @Override
    public Void visit(BreakStmt breakStmt) {
        return null;
    }

    @Override
    public Void visit(ContinueStmt continueStmt) {
        return null;
    }

    @Override
    public Void visit(ArrayLiteralExpr arrayLiteralExpr) {
        return null;
    }

    @Override
    public Void visit(IndexExpr indexExpr) {
        String target = exprToJava(indexExpr.target());   // not exprToString
        String index = exprToJava(indexExpr.index());

        // If index is a VenyInt â†’ call .intValue()
        if (indexExpr.index() instanceof LiteralExpr lit && lit.getValue() instanceof Integer i) {
            // Literal number â†’ direct int
            builder.appendLine(target + "[" + i + "]");
        } else {
            // Otherwise, unwrap
            builder.appendLine(target + "[" + index + ".raw()]");
        }

        return null;
    }

    private boolean insideConstructor() {
        // crude check: in constructor if method name == class name
        return currentClassName != null && currentMethodName != null
                && currentClassName.equals(currentMethodName);
    }

    private Void setEntryClassName(ClassDecl node) {
        for (MethodDecl method : node.methods()) {
            if (method.name().equals("entry") && method.parameters().size() == 1) {
                String paramType = method.parameters().get(0).type();
                if (paramType.equals("[Text]")) {  // Or use "String[]" if that's your internal name
                    entryClassName = node.name();
                    entryPackageName = currentPackageName;
                }
            }
        }
        return null;
    }

    private String mapVisibility(Visibility v) {
        return switch (v) {
            case PUBLIC -> "public";
            case PRIVATE -> "private";
            default -> ""; // package-private (no keyword in Java)
        };
    }

    private String mapType(String venyType) {
        if (venyType == null) {
            usedRuntimeImports.add("org.venylang.veny.runtime.core.VenyVoid");
            return "VenyVoid";
        }

        if (venyType.startsWith("[") && venyType.endsWith("]")) {
            String elem = venyType.substring(1, venyType.length() - 1);
            return mapType(elem) + "[]";
        }

        return switch (venyType) {
            case "Text" -> {
                usedRuntimeImports.add("org.venylang.veny.runtime.core.VenyText");
                yield "VenyText";
            }
            case "Int" -> {
                usedRuntimeImports.add("org.venylang.veny.runtime.core.VenyInt");
                yield "VenyInt";
            }
            case "Bool" -> {
                usedRuntimeImports.add("org.venylang.veny.runtime.core.VenyBool");
                yield "VenyBool";
            }
            case "Void", "void" -> {
                usedRuntimeImports.add("org.venylang.veny.runtime.core.VenyVoid");
                yield "VenyVoid";
            }
            default -> venyType;
        };
    }

    private boolean isVenyIntExpr(Expression expr) {
        if (expr instanceof LiteralExpr lit && lit.getValue() instanceof Integer) return true;
        if (expr instanceof VariableExpr var) {
            String t = var.name(); // if your AST stores type names
            return "Int".equals(t);
        }
        // Fallback
        return false;
    }

    private boolean isVenyTextExpr(Expression expr) {
        if (expr instanceof LiteralExpr lit && lit.getValue() instanceof String) return true;
        if (expr instanceof VariableExpr var) {
            String t = var.name();
            return "Text".equals(t);
        }
        return false;
    }

    /**
     * Given an expression generate a compilable Java code
     *
     * @param expr input expression
     * @return Java code
     */
    private String exprToJava(Expression expr) {
        if (expr == null) {
            return "null";
        }

        if (expr instanceof LiteralExpr lit) {
            if (lit.getValue() instanceof String s) {
                usedRuntimeImports.add("org.venylang.veny.runtime.core.VenyText");
                return "VenyText.of(\"" + s.replace("\"", "\\\"") + "\")";
            } else if (lit.getValue() instanceof Integer i) {
                usedRuntimeImports.add("org.venylang.veny.runtime.core.VenyInt");
                return "VenyInt.of(" + i + ")";
            } else if (lit.getValue() instanceof Boolean b) {
                usedRuntimeImports.add("org.venylang.veny.runtime.core.VenyBool");
                return "VenyBool.of(" + b + ")";
            }
        }

        if (expr instanceof VariableExpr var) {
            // Just return the variable name directly
            return var.name();
        }

        if (expr instanceof BinaryExpr bin) {
            String left  = exprToJava(bin.getLeft());
            String right = exprToJava(bin.getRight());

            Type leftType = bin.getLeft().getResolvedType();
            Type rightType = bin.getRight().getResolvedType();

            // Integer operations
            if (leftType == BuiltinType.INT && rightType == BuiltinType.INT) {
                return switch (bin.getOperator()) {
                    case "+" -> left + ".add(" + right + ")";
                    case "-" -> left + ".sub(" + right + ")";
                    case "*" -> left + ".mul(" + right + ")";
                    case "/" -> left + ".div(" + right + ")";
                    default -> "/* unsupported operator " + bin.getOperator() + " */";
                };
            }

            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Text operations
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (leftType == BuiltinType.TEXT && rightType == BuiltinType.TEXT) {
                return switch (bin.getOperator()) {
                    case "+"  -> left + ".add(" + right + ")";
                    case "==" -> left + ".equalsTo(" + right + ").raw()";
                    case "!=" -> "!" + left + ".equals(" + right + ")";
                    default   -> "/* unsupported operator " + bin.getOperator() + " */";
                };
            }

            // fallback raw operator (if needed)
            return left + " " + bin.getOperator() + " " + right;
        }

        if (expr instanceof UnaryExpr un) {
            return un.getOperator() + exprToJava(un.getOperand());
        }

        if (expr instanceof CallExpr call) {
            String args = call.arguments().stream()
                    .map(this::exprToJava)
                    .collect(Collectors.joining(", "));

            Expression calleeExpr = call.callee();

            //DEBUG System.out.println("CallExpr debug: calleeExpr class = " + calleeExpr.getClass().getSimpleName());

            if (calleeExpr instanceof VariableExpr var) {
                String name = var.name();
                if (knownClasses.contains(name)) {
                    // constructor call: Calculator(a,b) -> new Calculator(a,b)
                    return "new " + name + "(" + args + ")";
                }
                return var.name() + "(" + args + ")";
            }

            if (calleeExpr instanceof GetExpr get) {
                String target = exprToJava(get.target());

                if ((target.equals("Int") || target.equals("Bool") || target.equals("Text"))
                        && get.field().equals("of")) {

                    // common setup
                    if (call.arguments().size() != 1) {
                        //TODO error("Builtin factory '" + target + ".of' expects exactly 1 argument");
                        return "/* error: wrong arity */";
                    }
                    Expression argExpr = call.arguments().get(0);
                    Type argType = argExpr.getResolvedType();
                    String argJava = exprToJava(argExpr);

                    switch (target) {
                        case "Int" -> {
                            usedRuntimeImports.add("org.venylang.veny.runtime.core.VenyInt");
                            if (argType == BuiltinType.TEXT) {
                                return "VenyInt.of(Integer.parseInt(" + argJava + ".raw()))";
                            } else if (argType == BuiltinType.INT) {
                                return "VenyInt.of(" + argJava + ")";
                            } else {
                                //TODO error("Cannot convert " + argType + " to Int");
                                return "/* error: invalid Int.of(...) */";
                            }
                        }
                        case "Bool" -> {
                            usedRuntimeImports.add("org.venylang.veny.runtime.core.VenyBool");
                            if (argType == BuiltinType.TEXT) {
                                return "VenyBool.of(Boolean.parseBoolean(" + argJava + ".raw()))";
                            } else if (argType == BuiltinType.BOOL) {
                                return "VenyBool.of(" + argJava + ")";
                            } else {
                                //TODO error("Cannot convert " + argType + " to Bool");
                                return "/* error: invalid Bool.of(...) */";
                            }
                        }
                        case "Text" -> {
                            usedRuntimeImports.add("org.venylang.veny.runtime.core.VenyText");
                            if (argType == BuiltinType.TEXT) {
                                return argJava; // already a VenyText
                            } else {
                                return "VenyText.of(" + argJava + ")";
                            }
                        }
                    }
                }

                // Console special-case
                if ("Console".equals(target) &&
                        (get.field().equals("println") || get.field().equals("print"))) {
                    usedRuntimeImports.add("org.venylang.veny.runtime.core.ConsoleImpl");
                    return "ConsoleImpl.instance()." + get.field() + "(" + args + ")";
                }

                // General: target.method(...)
                String targetName = exprToJava(get.target());
                return (targetName.isEmpty() ? "" : targetName + ".") + get.field() + "(" + args + ")";
            }

            if (calleeExpr instanceof CallExpr nestedCall) {
                // recursively check nested calls
                String nested = exprToJava(nestedCall);
                if (nested.equals(currentClassName)) {
                    return ""; // skip self-constructor
                }
                return nested + "(" + args + ")";
            }

            String callee = exprToJava(calleeExpr);
            return callee + "(" + args + ")";
        }

        if (expr instanceof NewExpr ne) {
            if (insideEntryMethod && ne.className().equals(currentClassName)) {
                // Inside entry, calling the same class â†’ just "this"
                return "";
            }
            return "new " + ne.className() + "()";
        }

        if (expr instanceof GetExpr get) {
            // If the target is a NewExpr of the current class, treat as `this` (i.e., omit prefix)
            if (get.target() instanceof NewExpr ne && ne.className().equals(currentClassName)) {
                return get.field(); // just the method or field name
            }

            // Otherwise, recursively generate the target
            String target = exprToJava(get.target());
            return target + "." + get.field();
        }

        if (expr instanceof SetExpr set) {
            // object.field = value
            return exprToJava(set.target()) + "." + set.field() + " = " + exprToJava(set.value());
        }

        if (expr instanceof ArrayLiteralExpr arr) {
            String elems = arr.elements().stream()
                    .map(this::exprToJava)
                    .collect(Collectors.joining(", "));
            // In Java, must know the type. Assume semantic analysis gives elemTypeName.
            String type = mapType(arr.elementType().getName());
            return "new " + type + "[] { " + elems + " }";
        }

        if (expr instanceof AssignExpr assign) {
            return exprToJava(assign.value()) + " = " + exprToJava(assign.value());
        }

        if (expr instanceof IndexExpr idx) {
            String target = exprToJava(idx.target());
            String index = exprToJava(idx.index());

            if (idx.index() instanceof LiteralExpr lit && lit.getValue() instanceof Integer i) {
                return target + "[" + i + "]";
            } else {
                return target + "[" + index + ".intValue()]"; // unwrap VenyInt
            }
        }

        return "/* unsupported expr */";
    }

    private String exprToString(Expression expr) {
        if (expr == null) {
            return "null";
        }

        if (expr instanceof LiteralExpr lit) {
            if (lit.getValue() instanceof String s) return "\"" + s.replace("\"", "\\\"") + "\"";
            return lit.getValue().toString();
        }

        if (expr instanceof VariableExpr var) return var.name();

        if (expr instanceof BinaryExpr bin) {
            String left  = exprToString(bin.getLeft());
            String right = exprToString(bin.getRight());
            String op = bin.getOperator(); // can map to method if needed
            return "(" + left + " " + op + " " + right + ")";
        }

        if (expr instanceof UnaryExpr un) return un.getOperator() + exprToString(un.getOperand());

        if (expr instanceof CallExpr call) {
            String args = call.arguments().stream()
                    .map(this::exprToString)
                    .collect(Collectors.joining(", "));
            return exprToString(call.callee()) + "(" + args + ")";
        }

        if (expr instanceof NewExpr ne) return ne.className() + "()";

        if (expr instanceof GetExpr get) return exprToString(get.target()) + "." + get.field();

        if (expr instanceof SetExpr set) return exprToString(set.target()) + "." + set.field() + " = " + exprToString(set.value());

        if (expr instanceof ArrayLiteralExpr arr) {
            return "[" + arr.elements().stream().map(this::exprToString).collect(Collectors.joining(", ")) + "]";
        }

        if (expr instanceof AssignExpr assign) return exprToString(assign.value()) + " = " + exprToString(assign.value());

        if (expr instanceof IndexExpr idx) {
            String target = exprToString(idx.target());
            String index = exprToString(idx.index());

            if (idx.index() instanceof LiteralExpr lit && lit.getValue() instanceof Integer i) {
                return target + "[" + i + "]";
            } else {
                return target + "[" + index + ".raw()]";
            }
        }

        return "<unsupported-expr>";
    }

    /**
     * Return a simple default Java expression for the given Veny type name.
     * Adds any required runtime imports to usedRuntimeImports.
     * For unknown types returns "null".
     */
    private String defaultValueForType(String venyType) {
        if (venyType == null) {
            usedRuntimeImports.add("org.venylang.veny.runtime.core.VenyVoid");
            return "VenyVoid.get()";
        }

        if (venyType.startsWith("[") && venyType.endsWith("]")) {
            String elem = venyType.substring(1, venyType.length() - 1);
            return "new " + mapType(elem) + "[]{}";
        }

        switch (venyType) {
            case "Int" -> {
                usedRuntimeImports.add("org.venylang.veny.runtime.core.VenyInt");
                return "VenyInt.of(0)";
            }
            case "Text" -> {
                usedRuntimeImports.add("org.venylang.veny.runtime.core.VenyText");
                return "VenyText.of(\"\")";
            }
            case "Bool" -> {
                usedRuntimeImports.add("org.venylang.veny.runtime.core.VenyBool");
                return "VenyBool.of(false)";
            }
            case "Void", "void" -> {
                usedRuntimeImports.add("org.venylang.veny.runtime.core.VenyVoid");
                return "VenyVoid.get()";
            }
            default -> {
                // For classes and unknown types fall back to null
                return "null";
            }
        }
    }

    /**
     * Returns a standard auto-generated file header.
     *
     * @param generatorName the name of the generator (e.g., "Veny")
     * @param timestamp generation timestamp (e.g., from LocalDate.now() or similar)
     * @return the formatted header string
     */
    private String generateFileHeader(String generatorName, String timestamp) {
        return String.join("\n",
                "// ------------------------------------------------------------------------------",
                "// <auto-generated>",
                "//     This code was generated by " + generatorName + "`s Java Code Generator.",
                "//",
                "//     Changes to this file may be lost if the code is regenerated.",
                "//     Generated on: " + timestamp,
                "// </auto-generated>",
                "// ------------------------------------------------------------------------------"
        );
    }
}
