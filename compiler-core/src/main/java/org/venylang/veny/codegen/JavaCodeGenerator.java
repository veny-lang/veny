/*
 * Copyright 2025 Stoyan Petkov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package org.venylang.veny.codegen;

import org.venylang.veny.parser.ast.*;
import org.venylang.veny.parser.ast.expression.*;
import org.venylang.veny.parser.ast.statement.*;

import java.time.LocalDate;

/**
 * A visitor implementation that generates Java source code from a Veny AST.
 * <p>
 * This generator traverses the abstract syntax tree (AST) using the visitor pattern
 * and builds formatted Java code using a {@link CodeBuilder}. Currently, only class
 * and field declarations are partially implemented; other visit methods are placeholders.
 * </p>
 *
 * <p>Usage example:
 * <pre>{@code
 * Program ast = ... // Veny AST
 * JavaCodeGenerator generator = new JavaCodeGenerator();
 * String javaCode = ast.accept(generator);
 * System.out.println(javaCode);
 * }</pre>
 *
 * <p>The generated output includes a standard file header indicating that it was
 * auto-generated by the Veny compiler. This helps prevent manual edits and aids traceability.</p>
 *
 * @see AstVisitor
 * @see CodeBuilder
 */
public class JavaCodeGenerator implements AstVisitor<Void> {
    private final CodeBuilder builder = new CodeBuilder();
    private String entryClassName = null;
    private String entryPackageName = null;
    private String currentPackageName = null; // tracks package during file traversal

    private JavaCodeGenerator() {}

    /**
     * Factory method to generate code from a given Program node.
     *
     * @param program the root AST node
     * @return an instance of JavaCodeGenerator with code ready to fetch
     */
    public static JavaCodeGenerator of(Program program) {
        JavaCodeGenerator generator = new JavaCodeGenerator();
        program.accept(generator);
        return generator;
    }

    /**
     * Returns the generated Java source code as a string.
     */
    public String getCode() {
        return builder.build();
    }

    @Override
    public Void visit(Program node) {
        builder.appendRawLine(generateFileHeader("Veny", LocalDate.now().toString()))
                .appendRawLine(""); // blank line after header

        for (VenyFile file : node.files()) {
            file.accept(this);
            builder.appendRawLine(""); // separate files
        }

        if (entryClassName != null) {
            builder.appendRawLine(""); // space
            builder.appendRawLine("// Main launcher class");
            builder.appendLine("public class Main {")
                    .indent()
                    .appendLine("public static void main(String[] args) {")
                    .indent()
                    .appendLine("veny.lang.Text[] venyArgs = new veny.lang.Text[args.length];")
                    .appendLine("for (int i = 0; i < args.length; i++) {")
                    .indent()
                    .appendLine("venyArgs[i] = veny.lang.Text.of(args[i]);")
                    .unindent()
                    .appendLine("}");

            String fullEntryClass = (entryPackageName != null && !entryPackageName.isEmpty())
                    ? entryPackageName + "." + entryClassName
                    : entryClassName;

            builder.appendLine(fullEntryClass + ".entry(venyArgs);")
                    .unindent()
                    .appendLine("}")
                    .unindent()
                    .appendLine("}");
        }

        return null;
    }

    @Override
    public Void visit(VenyFile node) {
        currentPackageName = node.packageName();

        if (node.packageName() != null && !node.packageName().isEmpty()) {
            builder.appendLine("package " + node.packageName() + ";");
            builder.appendRawLine(""); // blank line after package
        }

        for (String imp : node.imports()) {
            builder.appendLine("import " + imp + ";");
        }

        if (!node.imports().isEmpty()) {
            builder.appendRawLine(""); // blank line after imports
        }

        for (ClassDecl cls : node.classes()) {
            cls.accept(this);
            builder.appendRawLine(""); // separate classes
        }

        return null;
    }

    @Override
    public Void visit(ClassDecl node) {
        StringBuilder classSignature = new StringBuilder("public class ").append(node.name());

        // Handle optional superclass (ext)
        if (node.parent() != null && !node.parent().isEmpty()) {
            classSignature.append(" extends ").append(node.parent());
        }

        // Handle implemented interfaces (impl)
        if (!node.interfaces().isEmpty()) {
            classSignature.append(" implements ");
            classSignature.append(String.join(", ", node.interfaces()));
        }

        builder.appendLine(classSignature.toString())
                .appendLine("{")
                .indent();

        for (VarDecl field : node.fields()) {
            field.accept(this);
        }

        if (!node.fields().isEmpty() && !node.methods().isEmpty()) {
            builder.appendRawLine(""); // Blank line between fields and methods
        }

        for (MethodDecl method : node.methods()) {
            method.accept(this);
            builder.appendRawLine(""); // Blank line between methods
        }

        builder.unindent()
                .appendLine("}");

        setEntryClassName(node);

        return null;
    }

    @Override
    public Void visit(InterfaceDecl node) {
        return null;
    }

    @Override
    public Void visit(VarDecl node) {
        String visibility = node.visibility().toString().toLowerCase();
        String line = visibility + " " + node.typeName() + " " + node.name() + ";";
        builder.appendLine(line);
        return null;
    }

    @Override
    public Void visit(MethodDecl node) {
        String visibility = node.visibility().toString().toLowerCase();
        StringBuilder params = new StringBuilder();

        for (int i = 0; i < node.parameters().size(); i++) {
            var param = node.parameters().get(i);
            params.append(param.type()).append(" ").append(param.name());
            if (i < node.parameters().size() - 1) {
                params.append(", ");
            }
        }

        builder.appendLine(visibility + " " + node.returnType() + " " + node.name() + "(" + params + ") {")
                .indent();

        for (Statement stmt : node.body()) {
            stmt.accept(this);
        }

        builder.unindent().appendLine("}");
        return null;
    }

    @Override
    public Void visit(BlockStmt node) {
        return null;
    }

    @Override
    public Void visit(IfStmt node) {
        return null;
    }

    @Override
    public Void visit(WhileStmt node) {
        return null;
    }

    @Override
    public Void visit(ForStmt node) {
        return null;
    }

    @Override
    public Void visit(ReturnStmt node) {
        return null;
    }

    @Override
    public Void visit(ExprStmt node) {
        return null;
    }

    @Override
    public Void visit(VarStmt node) {
        return null;
    }

    @Override
    public Void visit(ValStmt node) {
        return null;
    }

    @Override
    public Void visit(BinaryExpr node) {
        return null;
    }

    @Override
    public Void visit(UnaryExpr node) {
        return null;
    }

    @Override
    public Void visit(LiteralExpr node) {
        return null;
    }

    @Override
    public Void visit(VariableExpr node) {
        return null;
    }

    @Override
    public Void visit(AssignExpr node) {
        return null;
    }

    @Override
    public Void visit(CallExpr node) {
        return null;
    }

    @Override
    public Void visit(NewExpr node) {
        return null;
    }

    @Override
    public Void visit(GetExpr node) {
        return null;
    }

    @Override
    public Void visit(SetExpr node) {
        return null;
    }

    @Override
    public Void visit(BreakStmt breakStmt) {
        return null;
    }

    @Override
    public Void visit(ContinueStmt continueStmt) {
        return null;
    }

    @Override
    public Void visit(ArrayLiteralExpr arrayLiteralExpr) {
        return null;
    }

    private Void setEntryClassName(ClassDecl node) {
        for (MethodDecl method : node.methods()) {
            if (method.name().equals("entry") && method.parameters().size() == 1) {
                String paramType = method.parameters().get(0).type();
                if (paramType.equals("[Text]")) {  // Or use "String[]" if that's your internal name
                    entryClassName = node.name();
                    entryPackageName = currentPackageName;
                }
            }
        }
        return null;
    }

    /**
     * Returns a standard auto-generated file header.
     *
     * @param generatorName the name of the generator (e.g., "Veny")
     * @param timestamp generation timestamp (e.g., from LocalDate.now() or similar)
     * @return the formatted header string
     */
    private String generateFileHeader(String generatorName, String timestamp) {
        return String.join("\n",
                "// ------------------------------------------------------------------------------",
                "// <auto-generated>",
                "//     This code was generated by " + generatorName + "`s Java Code Generator.",
                "//",
                "//     Changes to this file may be lost if the code is regenerated.",
                "//     Generated on: " + timestamp,
                "// </auto-generated>",
                "// ------------------------------------------------------------------------------"
        );
    }
}
